# Streaming Quotes (OnSymbolTick)

> **Request:** subscribe to live ticks for one or more symbols. Uses gRPC streaming with two channels: **data** and **errors**.

---

### Code Example

```go
// High-level helper (inside MT5Service):
svc.StreamQuotes(ctx) // by default streams EURUSD, GBPUSD

// Low-level (pass your own symbols and handle packets):
symbols := []string{"EURUSD", "GBPUSD", "XAUUSD"}
ctx2, cancel := context.WithCancel(ctx)
defer cancel()

tickCh, errCh := s.account.OnSymbolTick(ctx2, symbols)
fmt.Println("üîÑ Streaming ticks...")
for {
    select {
    case pkt, ok := <-tickCh:
        if !ok { fmt.Println("‚úÖ Tick stream ended."); return }
        if st := pkt.GetSymbolTick(); st != nil {
            fmt.Printf("[Tick] %s | Bid: %.5f | Ask: %.5f | Time: %s\n",
                st.GetSymbol(), st.GetBid(), st.GetAsk(), st.GetTime().AsTime().Format("2006-01-02 15:04:05"))
        }
    case err := <-errCh:
        log.Printf("‚ùå Stream error: %v", err)
        return
    case <-time.After(30 * time.Second): // safety timeout for demos
        fmt.Println("‚è±Ô∏è Timeout reached.")
        return
    }
}
```

---

### Method Signature (helper)

```go
func (s *MT5Service) StreamQuotes(ctx context.Context)
```

**Under the hood:** calls `OnSymbolTick(ctx, symbols []string)` on the account client and forwards packets from its channels.

---

## üîΩ Input

| Parameter | Type              | Required | Description                                                                                                      |
| --------- | ----------------- | -------- | ---------------------------------------------------------------------------------------------------------------- |
| `ctx`     | `context.Context` | yes      | Controls lifetime of the stream (cancel/timeout).                                                                |
| `symbols` | `[]string`        | no\*     | Helper uses a built-in slice (e.g., `EURUSD`, `GBPUSD`). For a custom list, use the **low-level** example above. |

> \*In the helper, edit the `symbols := []string{...}` line to change the watch list.

---

## ‚¨ÜÔ∏è Output

Continuous packets on channels:

* **`tickCh`** (`<-chan *pb.SymbolTickPacket`)

  * `Symbol` ‚Äî e.g., `EURUSD`
  * `Bid`, `Ask` ‚Äî latest prices
  * `Time` ‚Äî server timestamp (`google.protobuf.Timestamp`)
* **`errCh`** (`<-chan error`) ‚Äî transport/stream errors

**Sample console output:**

```
[Tick] EURUSD | Bid: 1.09876 | Ask: 1.09889 | Time: 2025-08-17 12:00:01
[Tick] GBPUSD | Bid: 1.28543 | Ask: 1.28558 | Time: 2025-08-17 12:00:01
```

---

## üéØ Purpose

* Feed live prices into strategies, dashboards, or alerting.
* Validate connectivity and symbol availability in real time.

---

## üß© Notes & Tips

* **Symbol visibility:** make sure symbols are visible (`EnsureSymbolVisible`) before streaming.
* **Throttle logs:** printing every tick can flood stdout; batch or rate-limit in production.
* **Stop conditions:** stream ends when `ctx` is canceled, timeout fires, server closes the stream, or an error arrives on `errCh`.
* **Reconnect logic:** for long-running services, wrap with retry/backoff on errors.
* **Scope the list:** watch only the symbols you need to reduce traffic.

---

## ‚ö†Ô∏è Pitfalls

* No trading side-effects, but **high CPU/log I/O** possible if you print every tick.
* On quiet markets you may see long pauses ‚Äî —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ.

---

## Variations

* Change list: `symbols := []string{"EURUSD", "XAUUSD"}`.
* Remove demo timeout: drop the `time.After(...)` case to keep the stream open.
* Run several streams in parallel with a shared parent context and `sync.WaitGroup`.
