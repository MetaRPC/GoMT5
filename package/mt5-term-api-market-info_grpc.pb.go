// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: mt5-term-api-market-info.proto

package _go

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MarketInfoClient is the client API for MarketInfo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MarketInfoClient interface {
	// Returns the number of available (selected in Market Watch or all) symbols
	// https://www.mql5.com/en/docs/marketinformation/symbolstotal
	SymbolsTotal(ctx context.Context, in *SymbolsTotalRequest, opts ...grpc.CallOption) (*SymbolsTotalReply, error)
	// Checks if a symbol with a specified name exists
	// https://www.mql5.com/en/docs/marketinformation/symbolexist
	SymbolExist(ctx context.Context, in *SymbolExistRequest, opts ...grpc.CallOption) (*SymbolExistReply, error)
	// Returns the name of a symbol
	// https://www.mql5.com/en/docs/marketinformation/symbolname
	SymbolName(ctx context.Context, in *SymbolNameRequest, opts ...grpc.CallOption) (*SymbolNameReply, error)
	// Selects a symbol in the Market Watch window or removes a symbol from the window
	// https://www.mql5.com/en/docs/marketinformation/symbolselect
	SymbolSelect(ctx context.Context, in *SymbolSelectRequest, opts ...grpc.CallOption) (*SymbolSelectReply, error)
	// The function checks whether data of a selected symbol in the terminal are synchronized with data on the trade server.
	// https://www.mql5.com/en/docs/marketinformation/symbolissynchronized
	SymbolIsSynchronized(ctx context.Context, in *SymbolIsSynchronizedRequest, opts ...grpc.CallOption) (*SymbolIsSynchronizedReply, error)
	// Returns the corresponding property of a specified symbol. Immediately returns the property value.
	// https://www.mql5.com/en/docs/marketinformation/symbolinfodouble
	SymbolInfoDouble(ctx context.Context, in *SymbolInfoDoubleRequest, opts ...grpc.CallOption) (*SymbolInfoDoubleReply, error)
	// Returns the corresponding property of a specified symbol.
	// https://www.mql5.com/en/docs/marketinformation/symbolinfointeger
	SymbolInfoInteger(ctx context.Context, in *SymbolInfoIntegerRequest, opts ...grpc.CallOption) (*SymbolInfoIntegerReply, error)
	// Returns the corresponding property of a specified symbol. Immediately returns the property value
	// https://www.mql5.com/en/docs/marketinformation/symbolinfostring
	SymbolInfoString(ctx context.Context, in *SymbolInfoStringRequest, opts ...grpc.CallOption) (*SymbolInfoStringReply, error)
	// Returns the margin rates depending on the order type and direction
	// https://www.mql5.com/en/docs/marketinformation/symbolinfomarginrate
	SymbolInfoMarginRate(ctx context.Context, in *SymbolInfoMarginRateRequest, opts ...grpc.CallOption) (*SymbolInfoMarginRateReply, error)
	// The function returns current prices of a specified symbol in a variable of the MqlTick type
	// https://www.mql5.com/en/docs/marketinformation/symbolinfotick
	SymbolInfoTick(ctx context.Context, in *SymbolInfoTickRequest, opts ...grpc.CallOption) (*SymbolInfoTickRequestReply, error)
	// Allows receiving time of beginning and end of the specified quoting sessions for a specified symbol and day of week
	// https://www.mql5.com/en/docs/marketinformation/symbolinfosessionquote
	SymbolInfoSessionQuote(ctx context.Context, in *SymbolInfoSessionQuoteRequest, opts ...grpc.CallOption) (*SymbolInfoSessionQuoteReply, error)
	// Allows receiving time of beginning and end of the specified trading sessions for a specified symbol and day of week
	// https://www.mql5.com/en/docs/marketinformation/symbolinfosessiontrade
	SymbolInfoSessionTrade(ctx context.Context, in *SymbolInfoSessionTradeRequest, opts ...grpc.CallOption) (*SymbolInfoSessionTradeReply, error)
	// Provides opening of Depth of Market for a selected symbol, and subscribes for receiving notifications of the DOM changes
	// https://www.mql5.com/en/docs/marketinformation/marketbookadd
	MarketBookAdd(ctx context.Context, in *MarketBookAddRequest, opts ...grpc.CallOption) (*MarketBookAddReply, error)
	// Provides closing of Depth of Market for a selected symbol, and cancels the subscription for receiving notifications of the DOM changes
	// https://www.mql5.com/en/docs/marketinformation/marketbookrelease
	MarketBookRelease(ctx context.Context, in *MarketBookReleaseRequest, opts ...grpc.CallOption) (*MarketBookReleaseReply, error)
	// Returns a structure array MqlBookInfo containing records of the Depth of Market of a specified symbol
	// https://www.mql5.com/en/docs/marketinformation/marketbookget
	MarketBookGet(ctx context.Context, in *MarketBookGetRequest, opts ...grpc.CallOption) (*MarketBookGetReply, error)
}

type marketInfoClient struct {
	cc grpc.ClientConnInterface
}

func NewMarketInfoClient(cc grpc.ClientConnInterface) MarketInfoClient {
	return &marketInfoClient{cc}
}

func (c *marketInfoClient) SymbolsTotal(ctx context.Context, in *SymbolsTotalRequest, opts ...grpc.CallOption) (*SymbolsTotalReply, error) {
	out := new(SymbolsTotalReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolsTotal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolExist(ctx context.Context, in *SymbolExistRequest, opts ...grpc.CallOption) (*SymbolExistReply, error) {
	out := new(SymbolExistReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolExist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolName(ctx context.Context, in *SymbolNameRequest, opts ...grpc.CallOption) (*SymbolNameReply, error) {
	out := new(SymbolNameReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolSelect(ctx context.Context, in *SymbolSelectRequest, opts ...grpc.CallOption) (*SymbolSelectReply, error) {
	out := new(SymbolSelectReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolSelect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolIsSynchronized(ctx context.Context, in *SymbolIsSynchronizedRequest, opts ...grpc.CallOption) (*SymbolIsSynchronizedReply, error) {
	out := new(SymbolIsSynchronizedReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolIsSynchronized", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolInfoDouble(ctx context.Context, in *SymbolInfoDoubleRequest, opts ...grpc.CallOption) (*SymbolInfoDoubleReply, error) {
	out := new(SymbolInfoDoubleReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolInfoDouble", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolInfoInteger(ctx context.Context, in *SymbolInfoIntegerRequest, opts ...grpc.CallOption) (*SymbolInfoIntegerReply, error) {
	out := new(SymbolInfoIntegerReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolInfoInteger", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolInfoString(ctx context.Context, in *SymbolInfoStringRequest, opts ...grpc.CallOption) (*SymbolInfoStringReply, error) {
	out := new(SymbolInfoStringReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolInfoString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolInfoMarginRate(ctx context.Context, in *SymbolInfoMarginRateRequest, opts ...grpc.CallOption) (*SymbolInfoMarginRateReply, error) {
	out := new(SymbolInfoMarginRateReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolInfoMarginRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolInfoTick(ctx context.Context, in *SymbolInfoTickRequest, opts ...grpc.CallOption) (*SymbolInfoTickRequestReply, error) {
	out := new(SymbolInfoTickRequestReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolInfoTick", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolInfoSessionQuote(ctx context.Context, in *SymbolInfoSessionQuoteRequest, opts ...grpc.CallOption) (*SymbolInfoSessionQuoteReply, error) {
	out := new(SymbolInfoSessionQuoteReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolInfoSessionQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) SymbolInfoSessionTrade(ctx context.Context, in *SymbolInfoSessionTradeRequest, opts ...grpc.CallOption) (*SymbolInfoSessionTradeReply, error) {
	out := new(SymbolInfoSessionTradeReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/SymbolInfoSessionTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) MarketBookAdd(ctx context.Context, in *MarketBookAddRequest, opts ...grpc.CallOption) (*MarketBookAddReply, error) {
	out := new(MarketBookAddReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/MarketBookAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) MarketBookRelease(ctx context.Context, in *MarketBookReleaseRequest, opts ...grpc.CallOption) (*MarketBookReleaseReply, error) {
	out := new(MarketBookReleaseReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/MarketBookRelease", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketInfoClient) MarketBookGet(ctx context.Context, in *MarketBookGetRequest, opts ...grpc.CallOption) (*MarketBookGetReply, error) {
	out := new(MarketBookGetReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.MarketInfo/MarketBookGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MarketInfoServer is the server API for MarketInfo service.
// All implementations should embed UnimplementedMarketInfoServer
// for forward compatibility
type MarketInfoServer interface {
	// Returns the number of available (selected in Market Watch or all) symbols
	// https://www.mql5.com/en/docs/marketinformation/symbolstotal
	SymbolsTotal(context.Context, *SymbolsTotalRequest) (*SymbolsTotalReply, error)
	// Checks if a symbol with a specified name exists
	// https://www.mql5.com/en/docs/marketinformation/symbolexist
	SymbolExist(context.Context, *SymbolExistRequest) (*SymbolExistReply, error)
	// Returns the name of a symbol
	// https://www.mql5.com/en/docs/marketinformation/symbolname
	SymbolName(context.Context, *SymbolNameRequest) (*SymbolNameReply, error)
	// Selects a symbol in the Market Watch window or removes a symbol from the window
	// https://www.mql5.com/en/docs/marketinformation/symbolselect
	SymbolSelect(context.Context, *SymbolSelectRequest) (*SymbolSelectReply, error)
	// The function checks whether data of a selected symbol in the terminal are synchronized with data on the trade server.
	// https://www.mql5.com/en/docs/marketinformation/symbolissynchronized
	SymbolIsSynchronized(context.Context, *SymbolIsSynchronizedRequest) (*SymbolIsSynchronizedReply, error)
	// Returns the corresponding property of a specified symbol. Immediately returns the property value.
	// https://www.mql5.com/en/docs/marketinformation/symbolinfodouble
	SymbolInfoDouble(context.Context, *SymbolInfoDoubleRequest) (*SymbolInfoDoubleReply, error)
	// Returns the corresponding property of a specified symbol.
	// https://www.mql5.com/en/docs/marketinformation/symbolinfointeger
	SymbolInfoInteger(context.Context, *SymbolInfoIntegerRequest) (*SymbolInfoIntegerReply, error)
	// Returns the corresponding property of a specified symbol. Immediately returns the property value
	// https://www.mql5.com/en/docs/marketinformation/symbolinfostring
	SymbolInfoString(context.Context, *SymbolInfoStringRequest) (*SymbolInfoStringReply, error)
	// Returns the margin rates depending on the order type and direction
	// https://www.mql5.com/en/docs/marketinformation/symbolinfomarginrate
	SymbolInfoMarginRate(context.Context, *SymbolInfoMarginRateRequest) (*SymbolInfoMarginRateReply, error)
	// The function returns current prices of a specified symbol in a variable of the MqlTick type
	// https://www.mql5.com/en/docs/marketinformation/symbolinfotick
	SymbolInfoTick(context.Context, *SymbolInfoTickRequest) (*SymbolInfoTickRequestReply, error)
	// Allows receiving time of beginning and end of the specified quoting sessions for a specified symbol and day of week
	// https://www.mql5.com/en/docs/marketinformation/symbolinfosessionquote
	SymbolInfoSessionQuote(context.Context, *SymbolInfoSessionQuoteRequest) (*SymbolInfoSessionQuoteReply, error)
	// Allows receiving time of beginning and end of the specified trading sessions for a specified symbol and day of week
	// https://www.mql5.com/en/docs/marketinformation/symbolinfosessiontrade
	SymbolInfoSessionTrade(context.Context, *SymbolInfoSessionTradeRequest) (*SymbolInfoSessionTradeReply, error)
	// Provides opening of Depth of Market for a selected symbol, and subscribes for receiving notifications of the DOM changes
	// https://www.mql5.com/en/docs/marketinformation/marketbookadd
	MarketBookAdd(context.Context, *MarketBookAddRequest) (*MarketBookAddReply, error)
	// Provides closing of Depth of Market for a selected symbol, and cancels the subscription for receiving notifications of the DOM changes
	// https://www.mql5.com/en/docs/marketinformation/marketbookrelease
	MarketBookRelease(context.Context, *MarketBookReleaseRequest) (*MarketBookReleaseReply, error)
	// Returns a structure array MqlBookInfo containing records of the Depth of Market of a specified symbol
	// https://www.mql5.com/en/docs/marketinformation/marketbookget
	MarketBookGet(context.Context, *MarketBookGetRequest) (*MarketBookGetReply, error)
}

// UnimplementedMarketInfoServer should be embedded to have forward compatible implementations.
type UnimplementedMarketInfoServer struct {
}

func (UnimplementedMarketInfoServer) SymbolsTotal(context.Context, *SymbolsTotalRequest) (*SymbolsTotalReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolsTotal not implemented")
}
func (UnimplementedMarketInfoServer) SymbolExist(context.Context, *SymbolExistRequest) (*SymbolExistReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolExist not implemented")
}
func (UnimplementedMarketInfoServer) SymbolName(context.Context, *SymbolNameRequest) (*SymbolNameReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolName not implemented")
}
func (UnimplementedMarketInfoServer) SymbolSelect(context.Context, *SymbolSelectRequest) (*SymbolSelectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolSelect not implemented")
}
func (UnimplementedMarketInfoServer) SymbolIsSynchronized(context.Context, *SymbolIsSynchronizedRequest) (*SymbolIsSynchronizedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolIsSynchronized not implemented")
}
func (UnimplementedMarketInfoServer) SymbolInfoDouble(context.Context, *SymbolInfoDoubleRequest) (*SymbolInfoDoubleReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolInfoDouble not implemented")
}
func (UnimplementedMarketInfoServer) SymbolInfoInteger(context.Context, *SymbolInfoIntegerRequest) (*SymbolInfoIntegerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolInfoInteger not implemented")
}
func (UnimplementedMarketInfoServer) SymbolInfoString(context.Context, *SymbolInfoStringRequest) (*SymbolInfoStringReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolInfoString not implemented")
}
func (UnimplementedMarketInfoServer) SymbolInfoMarginRate(context.Context, *SymbolInfoMarginRateRequest) (*SymbolInfoMarginRateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolInfoMarginRate not implemented")
}
func (UnimplementedMarketInfoServer) SymbolInfoTick(context.Context, *SymbolInfoTickRequest) (*SymbolInfoTickRequestReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolInfoTick not implemented")
}
func (UnimplementedMarketInfoServer) SymbolInfoSessionQuote(context.Context, *SymbolInfoSessionQuoteRequest) (*SymbolInfoSessionQuoteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolInfoSessionQuote not implemented")
}
func (UnimplementedMarketInfoServer) SymbolInfoSessionTrade(context.Context, *SymbolInfoSessionTradeRequest) (*SymbolInfoSessionTradeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SymbolInfoSessionTrade not implemented")
}
func (UnimplementedMarketInfoServer) MarketBookAdd(context.Context, *MarketBookAddRequest) (*MarketBookAddReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketBookAdd not implemented")
}
func (UnimplementedMarketInfoServer) MarketBookRelease(context.Context, *MarketBookReleaseRequest) (*MarketBookReleaseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketBookRelease not implemented")
}
func (UnimplementedMarketInfoServer) MarketBookGet(context.Context, *MarketBookGetRequest) (*MarketBookGetReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarketBookGet not implemented")
}

// UnsafeMarketInfoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MarketInfoServer will
// result in compilation errors.
type UnsafeMarketInfoServer interface {
	mustEmbedUnimplementedMarketInfoServer()
}

func RegisterMarketInfoServer(s grpc.ServiceRegistrar, srv MarketInfoServer) {
	s.RegisterService(&MarketInfo_ServiceDesc, srv)
}

func _MarketInfo_SymbolsTotal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolsTotalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolsTotal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolsTotal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolsTotal(ctx, req.(*SymbolsTotalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolExist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolExist(ctx, req.(*SymbolExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolName(ctx, req.(*SymbolNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolSelect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolSelectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolSelect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolSelect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolSelect(ctx, req.(*SymbolSelectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolIsSynchronized_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolIsSynchronizedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolIsSynchronized(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolIsSynchronized",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolIsSynchronized(ctx, req.(*SymbolIsSynchronizedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolInfoDouble_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolInfoDoubleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolInfoDouble(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolInfoDouble",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolInfoDouble(ctx, req.(*SymbolInfoDoubleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolInfoInteger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolInfoIntegerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolInfoInteger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolInfoInteger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolInfoInteger(ctx, req.(*SymbolInfoIntegerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolInfoString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolInfoStringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolInfoString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolInfoString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolInfoString(ctx, req.(*SymbolInfoStringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolInfoMarginRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolInfoMarginRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolInfoMarginRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolInfoMarginRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolInfoMarginRate(ctx, req.(*SymbolInfoMarginRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolInfoTick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolInfoTickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolInfoTick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolInfoTick",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolInfoTick(ctx, req.(*SymbolInfoTickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolInfoSessionQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolInfoSessionQuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolInfoSessionQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolInfoSessionQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolInfoSessionQuote(ctx, req.(*SymbolInfoSessionQuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_SymbolInfoSessionTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolInfoSessionTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).SymbolInfoSessionTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/SymbolInfoSessionTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).SymbolInfoSessionTrade(ctx, req.(*SymbolInfoSessionTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_MarketBookAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketBookAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).MarketBookAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/MarketBookAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).MarketBookAdd(ctx, req.(*MarketBookAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_MarketBookRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketBookReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).MarketBookRelease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/MarketBookRelease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).MarketBookRelease(ctx, req.(*MarketBookReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarketInfo_MarketBookGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketBookGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketInfoServer).MarketBookGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.MarketInfo/MarketBookGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketInfoServer).MarketBookGet(ctx, req.(*MarketBookGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MarketInfo_ServiceDesc is the grpc.ServiceDesc for MarketInfo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MarketInfo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mt5_term_api.MarketInfo",
	HandlerType: (*MarketInfoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SymbolsTotal",
			Handler:    _MarketInfo_SymbolsTotal_Handler,
		},
		{
			MethodName: "SymbolExist",
			Handler:    _MarketInfo_SymbolExist_Handler,
		},
		{
			MethodName: "SymbolName",
			Handler:    _MarketInfo_SymbolName_Handler,
		},
		{
			MethodName: "SymbolSelect",
			Handler:    _MarketInfo_SymbolSelect_Handler,
		},
		{
			MethodName: "SymbolIsSynchronized",
			Handler:    _MarketInfo_SymbolIsSynchronized_Handler,
		},
		{
			MethodName: "SymbolInfoDouble",
			Handler:    _MarketInfo_SymbolInfoDouble_Handler,
		},
		{
			MethodName: "SymbolInfoInteger",
			Handler:    _MarketInfo_SymbolInfoInteger_Handler,
		},
		{
			MethodName: "SymbolInfoString",
			Handler:    _MarketInfo_SymbolInfoString_Handler,
		},
		{
			MethodName: "SymbolInfoMarginRate",
			Handler:    _MarketInfo_SymbolInfoMarginRate_Handler,
		},
		{
			MethodName: "SymbolInfoTick",
			Handler:    _MarketInfo_SymbolInfoTick_Handler,
		},
		{
			MethodName: "SymbolInfoSessionQuote",
			Handler:    _MarketInfo_SymbolInfoSessionQuote_Handler,
		},
		{
			MethodName: "SymbolInfoSessionTrade",
			Handler:    _MarketInfo_SymbolInfoSessionTrade_Handler,
		},
		{
			MethodName: "MarketBookAdd",
			Handler:    _MarketInfo_MarketBookAdd_Handler,
		},
		{
			MethodName: "MarketBookRelease",
			Handler:    _MarketInfo_MarketBookRelease_Handler,
		},
		{
			MethodName: "MarketBookGet",
			Handler:    _MarketInfo_MarketBookGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mt5-term-api-market-info.proto",
}
