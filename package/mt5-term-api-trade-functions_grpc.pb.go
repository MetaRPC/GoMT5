// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: mt5-term-api-trade-functions.proto

package _go

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TradeFunctionsClient is the client API for TradeFunctions service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradeFunctionsClient interface {
	// The function calculates the margin required for the specified order type, on the current account, in the current market environment not taking into account current pending orders and open positions. It allows the evaluation of margin for the trade operation planned. The value is returned in the account currency +
	// https://www.mql5.com/en/docs/trading/ordercalcmargin
	OrderCalcMargin(ctx context.Context, in *OrderCalcMarginRequest, opts ...grpc.CallOption) (*OrderCalcMarginReply, error)
	// The function calculates the profit for the current account, in the current market conditions, based on the parameters passed. The function is used for pre-evaluation of the result of a trade operation. The value is returned in the account currency. +
	// https://www.mql5.com/en/docs/trading/ordercalcprofit
	OrderCalcProfit(ctx context.Context, in *OrderCalcProfitRequest, opts ...grpc.CallOption) (*OrderCalcProfitReply, error)
	// Checks if there are enough money to execute a required Trade Operation Type +
	// https://www.mql5.com/en/docs/trading/ordercheck
	OrderCheck(ctx context.Context, in *OrderCheckRequest, opts ...grpc.CallOption) (*OrderCheckReply, error)
	// Returns the number of open positions +
	// https://www.mql5.com/en/docs/trading/positionstotal
	PositionsTotal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PositionsTotalReply, error)
}

type tradeFunctionsClient struct {
	cc grpc.ClientConnInterface
}

func NewTradeFunctionsClient(cc grpc.ClientConnInterface) TradeFunctionsClient {
	return &tradeFunctionsClient{cc}
}

func (c *tradeFunctionsClient) OrderCalcMargin(ctx context.Context, in *OrderCalcMarginRequest, opts ...grpc.CallOption) (*OrderCalcMarginReply, error) {
	out := new(OrderCalcMarginReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.TradeFunctions/OrderCalcMargin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeFunctionsClient) OrderCalcProfit(ctx context.Context, in *OrderCalcProfitRequest, opts ...grpc.CallOption) (*OrderCalcProfitReply, error) {
	out := new(OrderCalcProfitReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.TradeFunctions/OrderCalcProfit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeFunctionsClient) OrderCheck(ctx context.Context, in *OrderCheckRequest, opts ...grpc.CallOption) (*OrderCheckReply, error) {
	out := new(OrderCheckReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.TradeFunctions/OrderCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeFunctionsClient) PositionsTotal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PositionsTotalReply, error) {
	out := new(PositionsTotalReply)
	err := c.cc.Invoke(ctx, "/mt5_term_api.TradeFunctions/PositionsTotal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradeFunctionsServer is the server API for TradeFunctions service.
// All implementations should embed UnimplementedTradeFunctionsServer
// for forward compatibility
type TradeFunctionsServer interface {
	// The function calculates the margin required for the specified order type, on the current account, in the current market environment not taking into account current pending orders and open positions. It allows the evaluation of margin for the trade operation planned. The value is returned in the account currency +
	// https://www.mql5.com/en/docs/trading/ordercalcmargin
	OrderCalcMargin(context.Context, *OrderCalcMarginRequest) (*OrderCalcMarginReply, error)
	// The function calculates the profit for the current account, in the current market conditions, based on the parameters passed. The function is used for pre-evaluation of the result of a trade operation. The value is returned in the account currency. +
	// https://www.mql5.com/en/docs/trading/ordercalcprofit
	OrderCalcProfit(context.Context, *OrderCalcProfitRequest) (*OrderCalcProfitReply, error)
	// Checks if there are enough money to execute a required Trade Operation Type +
	// https://www.mql5.com/en/docs/trading/ordercheck
	OrderCheck(context.Context, *OrderCheckRequest) (*OrderCheckReply, error)
	// Returns the number of open positions +
	// https://www.mql5.com/en/docs/trading/positionstotal
	PositionsTotal(context.Context, *emptypb.Empty) (*PositionsTotalReply, error)
}

// UnimplementedTradeFunctionsServer should be embedded to have forward compatible implementations.
type UnimplementedTradeFunctionsServer struct {
}

func (UnimplementedTradeFunctionsServer) OrderCalcMargin(context.Context, *OrderCalcMarginRequest) (*OrderCalcMarginReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderCalcMargin not implemented")
}
func (UnimplementedTradeFunctionsServer) OrderCalcProfit(context.Context, *OrderCalcProfitRequest) (*OrderCalcProfitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderCalcProfit not implemented")
}
func (UnimplementedTradeFunctionsServer) OrderCheck(context.Context, *OrderCheckRequest) (*OrderCheckReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderCheck not implemented")
}
func (UnimplementedTradeFunctionsServer) PositionsTotal(context.Context, *emptypb.Empty) (*PositionsTotalReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PositionsTotal not implemented")
}

// UnsafeTradeFunctionsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradeFunctionsServer will
// result in compilation errors.
type UnsafeTradeFunctionsServer interface {
	mustEmbedUnimplementedTradeFunctionsServer()
}

func RegisterTradeFunctionsServer(s grpc.ServiceRegistrar, srv TradeFunctionsServer) {
	s.RegisterService(&TradeFunctions_ServiceDesc, srv)
}

func _TradeFunctions_OrderCalcMargin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderCalcMarginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeFunctionsServer).OrderCalcMargin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.TradeFunctions/OrderCalcMargin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeFunctionsServer).OrderCalcMargin(ctx, req.(*OrderCalcMarginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradeFunctions_OrderCalcProfit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderCalcProfitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeFunctionsServer).OrderCalcProfit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.TradeFunctions/OrderCalcProfit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeFunctionsServer).OrderCalcProfit(ctx, req.(*OrderCalcProfitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradeFunctions_OrderCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeFunctionsServer).OrderCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.TradeFunctions/OrderCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeFunctionsServer).OrderCheck(ctx, req.(*OrderCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradeFunctions_PositionsTotal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeFunctionsServer).PositionsTotal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mt5_term_api.TradeFunctions/PositionsTotal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeFunctionsServer).PositionsTotal(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TradeFunctions_ServiceDesc is the grpc.ServiceDesc for TradeFunctions service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TradeFunctions_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mt5_term_api.TradeFunctions",
	HandlerType: (*TradeFunctionsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OrderCalcMargin",
			Handler:    _TradeFunctions_OrderCalcMargin_Handler,
		},
		{
			MethodName: "OrderCalcProfit",
			Handler:    _TradeFunctions_OrderCalcProfit_Handler,
		},
		{
			MethodName: "OrderCheck",
			Handler:    _TradeFunctions_OrderCheck_Handler,
		},
		{
			MethodName: "PositionsTotal",
			Handler:    _TradeFunctions_PositionsTotal_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mt5-term-api-trade-functions.proto",
}
